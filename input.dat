; some definitions
; (c ? e1 : e2) = λc.λe1.λe2.((c e1) e2)
; true = select_first = λa.λb.a
; false = select_second = λa.λb.b
; ((([cond] [true]) e1) e2) --macros like this would be nice
; NOT(x) = (λx.(((λc.λe1.λe2.((c e1) e2) x) λa.λb.b) λa.λb.b) x)
; [NOT(x)]:=(λc.λe1.λe2.((c λa.λb.b) λa.λb.a) x) -- or macro like this
; 
; 
; Not (x) (takes boolean and negates it)
;(λx.(((λcond.λe1.λe2.((cond e1) e2) x) λa.λb.b) λz.λy.z) λc.λd.d)
; 
;===========;
; And (a,b) ;
;===========;
; λa.λb.((a b) λ_.λx.x)
;===========;
;((λa.λb.(b a) world) (λx.x hello))
;((1 2) ((((λx.x λa.λb.a) (3 4)) 1st) 2nd))
;((λa.λb.(b a) world) hello)
;
;((λa.λx.(x a) 32) λb.(b a))
;(λa.λx.(x a) 32)
;(λa.(λb.(b a) a) 32)
; 
; testing stuff
; λx.(λb.b (λa.a thing))
; 
;(((λa.λb.λc.(a b) λc2.(b2 c2)) hot) dog)
;((λfunc.λarg.(func arg) arg') boing)
;((λf.λa.(f a) λx.(x a_)) 32)
;(λa.(λb.(b a) λx.x) λy.(y b_))
;
;((^func.^arg.(func arg) arg) _arg)
;(^arg.(func arg) func)
;^x.(y x)
;
;
;
;
;((^func.^arg.(func arg) arg) 3)
;((^func.^arg.(func z) z) 3)
;(^x.(x y) y)
;(() ^x.(x x))
;Application(Function Expression)
;((^func.^arg.(func arg) myFunc) myArg)
;
;
;
;
;
;
;
;Church numerals
;0 = ^f.^x.x
;1 = ^f.^x.(f x)
;2 = ^f.^x.((f f) x)
;3 = ^f.^x.(((f f) f) x)
;4 = ^f.^x.((((f f) f) f) x)
;succ = ^n.^f.^x.(f ((m f) x))
(^n.^f.^x.(f ((n f) x)) ^f.^x.((((f f) f) f) x))
